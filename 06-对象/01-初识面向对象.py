"""
Python 是一种支持面向对象编程（OOP）的语言。面向对象编程通过定义类和对象来组织代码，将数据和行为结合在一起


1. 类与对象（Class & Object）
	•	类是对象的蓝图，定义了对象的属性（数据）和方法（行为）。
	•	对象是类的实例，是实际的数据和行为。

类和对象的关系
类是对象的模板，实例化类时创建的对象是这个模板的一个具体实现。每个类都包含了属性（对象的数据）和方法（对象的行为）。
	•	类定义了对象的属性和行为。
	•	对象是类的实例，代表了在内存中真实存在的具体数据。
    先要有类, 才能出现对象
        对象是类进行实例化之后才能产出的一种对象


类由三部分构成
    1.类名
    2.属性 -- 一组数据
    3.方法 -- 行为


class 类名:
    在当前位置定义属性与方法...
"""


class Person:
    # 类的属性
    species = "Homo sapiens"

    # 构造方法，初始化实例属性
    def __init__(self, name, age):
        self.name = name
        self.age = age

    # 实例方法
    def greet(self):
        return f"Hello, my name is {self.name} and I am {self.age} years old."


# 创建对象
p1 = Person("Alice", 30)
print(p1.greet())  # 输出: Hello, my name is Alice and I am 30 years old.


"""
说明：
	•	__init__ 是构造方法（初始化方法），在创建对象时自动调用，设置对象的初始状态。
	•	self 代表当前对象的实例，类中的方法第一个参数通常是 self，它是访问实例属性和方法的方式。
"""

# 类的实例化 创建对象
"""
创建一个对象的具体格式: 代码示例中的中括号代表可选
    变量名 = 类名([参数1, 参数2...])

    在函数名的后面加上()代表的是调用
        但是在类中加上小括号代表的是实例化
        实例化 -- 根据这个类提供的信息创建了一个具有自己的属性和行为的一个对象
            实例对象
类名的定义要使用大驼峰命名法
类名严格区分大小写,类名遵循标识符的命名规则
"""

class Person:
    # 可以定义这个类共同具有的行为[方法]与特征[属性]代码
    def __init__(self, name, gender):  # 定义特征的方法
        self.name = name
        self.gender = gender

    # 一个类共用具有的行为可以使用函数定义, 如果一个函数在一个类的内部, 不能被称之为函数: 方法
    def run(self):
        print(f'{self.name}正在跑...')


p = Person('木木', '女')

# 根据这个类实例化产出的对象进行行为调用
p.run()


# 类的 __init__ 方法

"""
__init__ 是 Python 中类的构造方法（也叫初始化方法），它在创建对象时自动调用，用来初始化对象的属性。
在一个类中定义实例方法时, 实例方法中必须要有一个参数: self
    如果一个方法中的第一个参数的名字叫self, 则这个方法一定是一个实例方法

如何调用类中的实例方法
    1.创建当前这个类的实例对象
    2.根据这个实例对象打点调用对应方法

    一个对象可以分别调用不同的实例方法
        只要是实例对象则可以重复的调用不同的实例方法

 self 的作用    可以在方法内部调用实例所拥有的属性或者方法
 
3. 实例方法与 self 参数
	•	实例方法必须包括self参数，self代表当前对象的实例，是通过该实例访问对象属性和其他方法的方式。
	•	实例属性：每个实例对象都有自己的数据，通常通过self来访问。
"""

class Hero:
    def test_1(self):
        print('这是一个实例方法')

    def test_2(self, age):
        print(age)

    def test_3(self):
        print('这是一个实例方法: test_3')


h = Hero()
h.test_1()
h.test_1()
h.test_2(10)
h.test_3()

# 类的实例属性

"""
实例属性本质其实就是在类中的变量
    实例属性如何区分？
        1.只要属性名称的前面加上了self.前缀 则这个属性就可以确定为一个实例属性
        2.如果一个实例对象创建了一个变量, 则这个变量也是一个实例属性
        3.如果使用类对象访问属性报错, 则这个属性基本确定为一个实例属性

    实例属性必须使用实例对象去访问
        类对象
        实例对象
"""

"""
# 在类的外部可以添加或获取实例属性
# 格式:
# 实例属性添加:对象.属性名 = 值
# 实例属性获取:对象.属性名

在类的外部使用对象名,其实使用的是对象的引用地址,在其引用地址位置添加了对应的实例属性
在类的内部使用self,其实也代表该应用地址,也是在其应用地址位置添加了对饮的实例属性

为什么在类的内部要使用self 而不使用对象名?   简便,灵活.复用性高
1.我们每次使用的对象不一致,如果使用对象名,需要每次都传入不同的对象名,或者每个对象定义一个方法,这样不利于代码的复用.
2.在某些时刻,我们在没有将对象赋值给变量的时候,就需要添加其属性,这个时候,没有办法获取对象的名称.

4. 实例属性的创建与访问
	•	实例属性通常在构造方法 __init__ 中定义，但也可以在实例方法中动态创建。
	•	实例属性由实例对象本身拥有，无法通过类直接访问。
"""
class Person:
    def __init__(self, name):
        self.name = name  # 实例属性

    def change_name(self, new_name):
        self.name = new_name  # 修改实例属性

p = Person("Alice")
print(p.name)  # 输出: Alice
p.change_name("Bob")
print(p.name)  # 输出: Bob
"""
# 实例属性在类的内部添加或获取的格式
# self.属性名 = 值
"""


"""
5. 类属性与实例属性的区别
	•	类属性：是属于类的属性，所有实例共享一个类属性。
	•	实例属性：是每个实例独立的属性，每个实例都有自己独立的数据。
"""
class Dog:
    species = "Canine"  # 类属性

    def __init__(self, name):
        self.name = name  # 实例属性

dog1 = Dog("Buddy")
dog2 = Dog("Max")

print(dog1.species)  # 输出: Canine
print(dog2.species)  # 输出: Canine
print(dog1.name)     # 输出: Buddy
print(dog2.name)     # 输出: Max
# 关于实例属性创建的三种方式




"""
1.使用实例对象动态创建
2.使用__init__方法创建实例属性
3.使用实例方法创建实例属性
"""


# 特殊情况下的self参数
class Person:
    def run(self):
        print(self)
        print('正在跑...')


# 使用实例对象调用方法时, python在内部会把实例对象本身自动传递给self
# 但是如果使用的是类名调用方法时, 那么self参数是需要自己手动传递的, 如果传递的不是实例对象本身,那么self就不是实例对象
Person.run('1')

p = Person()
p.run()

# 使用实例对象调用__class__方法获取到的是这个类在内存中的地址
p.__class__.run(p)  # 一个实例对象调用类中的方法的完整代码

"""
总结:
    self本身其实没有任何特殊含义,只是一个普通的参数而已
    在实例对象调用实例方法的时候, python在底层调用了__class__属性找到类的内存地址, 根据这个内存地址找到类的内部代码
        当调用内部方法时, 会自动传递调用对象本身

    实例对象调用方法中的self是实例对象本身!!!
"""

# 创建多个实例对象

class Dog:
    def __init__(self):
        self.dog_name = None

    def run(self):
        print(f'{self.dog_name}正在跑...')


dog_1 = Dog()
dog_1.dog_name = '哈士奇'

dog_2 = Dog()
dog_2.dog_name = '金毛'

dog_2.run()
dog_1.run()

"""
实例对象与实例对象之间是内存隔离的
    每一个创建出来的实例对象都有自己的属性, 并占用属于自己的内存空间

多个对象是有一个类创建的, 多个对象能不能访问同一个类？
"""

print(id(dog_1.__class__))
print(id(dog_2.__class__))
